---
date: 2021-03-03T12:19:04+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "Ffmepg Doc 01 Overview"  # 文章标题
# description: "文章描述"
url:  "posts/ffmpeg/docs/ch01_overview"  # 设置网页永久链接
tags: [ "ffmpeg"]  # 标签
series: [ "FFmpeg 从入门到放弃"]  # 文章主题/文章系列
categories: [ "学习笔记"]  # 文章分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

## 命令语法

```
ffmpeg [全局选项] {[输入文件选项] -i 输入文件} ... {[输出文件选项] 输出文件} ...
```

```
ffmpeg [global_options] {[input_file_options] -i input_file} ... {[output_file_options] output_file} ...
```

## 描述/概览

`ffmpeg` 是一个非常快的视频 / 音频转换器，其也可以现场抓取音频 / 视频源，并在任意采样率、尺寸之间调整视频，以及提供多种高品质的滤镜系统。

`ffmpeg` 从任意数量 / 形式的输入文件中进行读取（可以是普通文件，管道，网络流，设备源等等），通过输入文件选项对输入文件进行设定，通过 `-i` 进行标记，并写入到任意数量 / 形式的输出文件中，任何在命令行中不能被解释为选项的字符串信息（当然也不是被 `-i` 指定为输入文件的信息）都被作为一个输出文件。

原则上每个输入或输出文件都可包含数量不同的数据流（视频 / 音频 / 字幕 / 附件 / 数据.... ）, 具体文件中包含的数量和 / 或数据类型是文件的容器格式限定的，具体选择那些流从输入文件到输出文件则可能是自动或者依据 `-map` 选项来指定。

为了明确指定输入文件，你必须采用从 0 开始的数字索引法，即第 1 个输入文件由 `0` 索引，第 2 个则是 `1`。同样的，在一个文件中指定数据流也是通过同样规则的索引法，即 `2:3` 表示第 3 个输入文件的第 4 个数据流。

默认情况下，`ffmpeg` 把输入文件每种类型（视频、音频和字幕）仅仅采用一个流转换输出到输出文件中，就是把*最好*效果的流进行输出：对于视频就是质量最高的流，对于音频就是包含最多声道的，对于字幕则是第一个字幕轨道，如果有多个同型同率（同样类型，码率相同）则选用索引号最小的流。

当然，你可以禁用默认设置，而采用 `-vn/-an/-sn` 选项进行专门的指定，如果要进行完全的手动控制，则是以 `-map` 选项，它将禁止默认值而选用指定的配置。

作为一般规则，选项用于指定紧接着的文件，因此命令中顺序很重要，你可以在命令中多次重复相同的选项，每次都可以应用于紧接着的下一个输入或者输出文件。例外的是全局选项（例如过程信息输出详细程度的选项），这些选项必须首先进行指定，会全局使用。

不要混淆输入和输出文件，要先指定所有的输入文件，然后才是所有的输出文件。也不要混淆选项应用的不同文件，所有的选项**仅仅**作用于紧接着的输入或者输出文件，除非**重复指定选项**才能作用于其他需要同样设定的文件。

- 设定输出视频码率为 64kbit/s：

```shell
ffmpeg -i input.avi -b:v 64k -bufsize 64k output.avi
```

- 切换帧率到24fps：

```shell
ffmpeg -i input.avi -r 24 output.avi
```

- 强制把输入文件帧率设为 1fps （仅建议 raw 格式数据）， 并且把输出文件帧率设置为 24fps：

```shell
ffmpeg -r 1 -i input.m2v -r 24 output.avi`
```

这里的输入文件必须是 raw 格式的输入文件。

## 详细说明

`ffmpeg` 的每个转换过程像下图描述的程序


```
     _______              ______________
	|       |            |              |
	| input |  demuxer   | encoded data |   decoder
	| file  | ---------> | packets      | -----+
	|_______|            |______________|      |
    	                                       v
    	                                   _________
    	                                  |         |
    	                                  | decoded |
    	                                  | frames  |
    	                                  |_________|
 	 ________             ______________       |
	|        |           |              |      |
	| output | <-------- | encoded data | <----+
	| file   |   muxer   | packets      |   encoder
	|________|           |______________|
```

`ffmpeg` 调用 `libavformat` 库（含分离器）读取输入文件，分离出各类编码的数据包（流），当有多个输入文件时，`ffmpeg` 试图跟踪最低时间戳实现任意输入流同步。编码数据包通过解码器解码出非压缩的数据帧（ raw 视频 /PCM 格式音频... ），这些数据帧可以被滤镜进一步处理（下面会讲到）。经过滤镜处理的数据被重新编码为新的数据包（流），然后经过混合器混合（例如按一定顺序和比例把音频数据包和视频数据包交叉组合），写入到输出文件。

### 滤镜处理 / Filtering

在编码前，`ffmpeg` 可以对 raw 音频和视频使用 `libavfilter` 库中的滤镜进行处理。多个滤镜可以组成滤镜链图（滤镜链图 filtergraphs ）。

在 `ffmpeg` 看来只有 2 种滤镜：简单滤镜，复合滤镜。

#### 简单滤镜

简单滤镜就是只有 1 个输入和输出的滤镜，滤镜两边的数据都是同一类型的，可以理解为在非压缩数据帧到再次编码前简单附加了一步:

```
	 _________                        ______________
	|         |                      |              |
	| decoded |                      | encoded data |
	| frames  |\                   _ | packets      |
	|_________| \                  /||______________|
	           	 \   __________   /
	  simple     _\||          | /  encoder
	  filtergraph   | filtered |/
	                | frames   |
	                |__________|
```

简单滤镜一般用于配置每个流 -filter 选项（-vf 和 -af 分别对应视频和音频）。一个最简单的视频滤镜如下:

> 
	 _______        _____________        _______        ________
	|       |      |             |      |       |      |        |
	| input | ---> | deinterlace | ---> | scale | ---> | output |
	|_______|      |_____________|      |_______|      |________|


**注意**一些滤镜改变帧属性而不是帧内容。例如前面提到的 fps 滤镜就只是引起帧率的变化，但不处理帧内容，另外一个例子是 setpts 则仅仅设置时间戳，通过滤镜的帧内容完全不变化。

#### 复合滤镜

复合滤镜是那些不能简单描述为一个线性处理过程应用到一个流的情况，例如当过程中有多个输入和/或输出，或者输出流类型不同于输入时，示意图如下：

> 
	 _________
	|         |
	| input 0 |\                    __________
	|_________| \                  |          |
	             \   _________    /| output 0 |
	              \ |         |  / |__________|
	 _________     \| complex | /
	|         |     |         |/
	| input 1 |---->| filter  |\
	|_________|     |         | \   __________
	               /| graph   |  \ |          |
	              / |         |   \| output 1 |
	 _________   /  |_________|    |__________|
	|         | /
	| input 2 |/
	|_________|

复合滤镜由 `-filter_complex` 选项进行设定。**注意**这是一个全局选项，因为一个复合滤镜必然是不能只关联到一个单一流或者文件的。`-lavfi` 选项等效于 `-filter_complex`

一个复合滤镜的简单例子就是 `overlay` 滤镜，它从两路输入中，把一个视频叠加到一个输出上。对应的类似音频滤镜是 `amix`。

### 流拷贝

流拷贝（ Stream Copy ）是一种对指定流数据仅仅进行复制的 ` 拷贝 copy` 模式。这种情况下 `ffmpeg` 不会对指定流进行解码和编码步骤，而仅仅是分离和混合数据包。这种模式常用于文件包装格式的转换或者修改部分元数据信息，这个过程简单图示如下：

> 
	 _______              ______________            ________
	|       |            |              |          |        |
	| input |  demuxer   | encoded data |  muxer   | output |
	| file  | ---------> | packets      | -------> | file   |
	|_______|            |______________|          |________|

因为这种模式下不存在解码和编码过程，所以也特别快，而且不会造成新的质量损失。然而这也使得这样的模式不能适合很多工作需求，例如这个模式下不能使用大量的滤镜了，因为滤镜仅能对未压缩（编码）的数据进行处理。
